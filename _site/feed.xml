<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-10-22T13:46:13+02:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Lorrens’ blog</title><subtitle>This is where I share stuff I work on or find interesting</subtitle><author><name>Lorrens Pantelis</name></author><entry><title type="html">GSoC ‘25 Work Product: Parallel Macro Expansion</title><link href="http://localhost:4000/2025/10/20/GSoC-Parallel-Macro_Expansion.html" rel="alternate" type="text/html" title="GSoC ‘25 Work Product: Parallel Macro Expansion" /><published>2025-10-20T00:00:00+02:00</published><updated>2025-10-20T00:00:00+02:00</updated><id>http://localhost:4000/2025/10/20/GSoC-Parallel-Macro_Expansion</id><content type="html" xml:base="http://localhost:4000/2025/10/20/GSoC-Parallel-Macro_Expansion.html"><![CDATA[<h1 id="the-project">The project</h1>

<p>A lot of work has been done to parallelize the rust compiler, some parts are already parallelized like codegen and processes after
HIR-lowering, such as type-checking, borrow-checking and MIR optimization. For this years GSoC project I had a chance to try and parallelize the macro expansion algorithm.</p>

<h1 id="preface">Preface</h1>

<p>While the title of this post includes “<strong>Parallel</strong> Macro Expansion”, I actually never got to parallelize the algorithm. This was due to sheer (unexpected) complexity of the project and
the numerous issues/roadblocks that came as the project went on (one such roadblock even <a href="https://rust-lang.zulipchat.com/#narrow/channel/421156-gsoc/topic/Project.3A.20Parallel.20Macro.20Expansion/near/542317541">surprised</a> my mentor).
This post will highlight the changes I made and the issues/roadblocks we faced.</p>

<h1 id="the-idea">The idea</h1>

<p>The current algorithm is order-dependent, which prevents parallelization. Simply put, it looks like this:</p>

<ol>
  <li>Collect unresolved imports and macro invocations.</li>
  <li>Resolve a single collected import.</li>
  <li>Commit: writeback the resolved import into modules.</li>
  <li>IF PROGRESS GOTO 1</li>
  <li>Resolve a single collected macro.</li>
  <li>Commit: expand the resolved macro.</li>
  <li>IF PROGRESS GOTO 4</li>
  <li>GOTO 1</li>
</ol>

<p>The idea is to parallelize <code class="language-plaintext highlighter-rouge">2-4</code>, which we call import resolution, and <code class="language-plaintext highlighter-rouge">5-7</code>, which we call macro expansion<sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>.</p>

<h1 id="my-work">My work</h1>

<p>As said before, I was meant to do both parts of the algorithm, but I only made progress on the import resolution algorithm. To be complete, I’ll explain this briefly as well.</p>

<p>It iteratively resolves undetermined imports until no further progress can be made, committing each resolved import to the module resolutions before proceeding. The goal is to isolate
these resolutions so that each import in the undetermined set can be processed independently and committed afterwards. We called this batched import resolution, because resolving and
committing are done over the entire <em>batch</em> of undetermined imports.</p>

<p>As some of you may observe, we would also need to remove any kind of mutability in the resolver that happens during this, as to not create conflicts with other imports that are being resolved.</p>

<p>If we successfully implemented above 2 points, it would be trivial to parallelize the algorithm.</p>

<h2 id="removing-mutability">Removing mutability</h2>

<p>Some of these essentially boil down to splitting collections of items into 2 separate collections, one for crate local items and one for external crate items. This is because external crate items
are lazily populated during resolution. You can see these external items as a cache, which do not affect the resolutions of the crate local items.</p>

<h3 id="macro-maps">Macro Maps</h3>
<p>One of these collections is the <code class="language-plaintext highlighter-rouge">macro_map</code>, which was read from or updated in this method:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">fn</span> <span class="nf">get_macro_by_def_id</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">def_id</span><span class="p">:</span> <span class="n">DefId</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">MacroData</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">self</span><span class="py">.macro_map</span><span class="nf">.contains_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">def_id</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.macro_map</span><span class="p">[</span><span class="o">&amp;</span><span class="n">def_id</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">let</span> <span class="n">macro_data</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span> <span class="c1">// not relevant</span>
    <span class="k">self</span><span class="py">.macro_map</span><span class="nf">.entry</span><span class="p">(</span><span class="n">def_id</span><span class="p">)</span><span class="nf">.or_insert</span><span class="p">(</span><span class="n">macro_data</span><span class="p">)</span> <span class="c1">// the mutable call</span>
<span class="p">}</span>
</code></pre></div></div>

<p>However, local macros were always present in the map when this method was called, so it was only updated here when we added an external macro.
<a href="https://github.com/rust-lang/rust/pull/143657">This PR</a> fixed this by splitting the maps and changed the logic to account for this.</p>

<h3 id="defining-bindings">Defining bindings</h3>

<p>A very important method of the resolver is <code class="language-plaintext highlighter-rouge">define_binding</code>, anytime a particular binding (i.e. a name pointing to a thing) should be added to a module, you would call this method:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">fn</span> <span class="nf">define_binding</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span>
        <span class="n">parent</span><span class="p">:</span> <span class="n">Module</span><span class="o">&lt;</span><span class="nv">'ra</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">ident</span><span class="p">:</span> <span class="n">Ident</span><span class="p">,</span>
        <span class="n">ns</span><span class="p">:</span> <span class="n">Namespace</span><span class="p">,</span>
        <span class="n">binding</span><span class="p">:</span> <span class="n">NameBinding</span><span class="o">&lt;</span><span class="nv">'ra</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">);</span>
</code></pre></div></div>

<p>However, this was called for local and external bindings, but during import resolution only for external items. <a href="https://github.com/rust-lang/rust/pull/143884">This PR</a>
introduced <code class="language-plaintext highlighter-rouge">define_local</code> and <code class="language-plaintext highlighter-rouge">define_extern</code>, where <code class="language-plaintext highlighter-rouge">define_extern</code> took a <code class="language-plaintext highlighter-rouge">&amp;self</code>. It allowed us to change a lot of methods from <code class="language-plaintext highlighter-rouge">&amp;mut self</code> to <code class="language-plaintext highlighter-rouge">&amp;self</code>.
The main blocker here were underscore disambiguators (a way to differentiate <code class="language-plaintext highlighter-rouge">_</code> items) and external module maps (remember macro maps), fixed by <a href="https://github.com/petrochenkov">Vadim Petrochenkov</a> in <a href="https://github.com/rust-lang/rust/pull/144272">#144272</a> and <a href="https://github.com/rust-lang/rust/pull/143550">#143550</a> respectively.</p>

<h3 id="smaller-but-relevant-changes">Smaller but relevant changes</h3>

<h4 id="crateloader">CrateLoader</h4>

<p>For some reason the <code class="language-plaintext highlighter-rouge">CrateLoader</code> was still used by the resolver when handling with the <code class="language-plaintext highlighter-rouge">CStore</code>, the code that interacts with all the external crates. This required a <code class="language-plaintext highlighter-rouge">&amp;mut Resolver</code> in a lot of places,
but the <code class="language-plaintext highlighter-rouge">CStore</code> did not (it goes through <code class="language-plaintext highlighter-rouge">TyCtx</code>, out of scope here). <a href="https://github.com/rust-lang/rust/pull/144059">This PR</a> refactored the logic of the <code class="language-plaintext highlighter-rouge">CrateLoader</code> into the <code class="language-plaintext highlighter-rouge">CStore</code>.</p>

<h4 id="cachify-externpreludeentrybinding">Cachify <code class="language-plaintext highlighter-rouge">ExternPreludeEntry.binding</code></h4>

<p>Updating this field is classified as a cache and was thus wrapped in a <code class="language-plaintext highlighter-rouge">Cell</code> in <a href="https://github.com/rust-lang/rust/pull/144605">#144605</a>.</p>

<h3 id="conditional-mutable-resolver">Conditional Mutable Resolver</h3>

<p>The above refactors were crucial for this to work, but some methods could not be fixed this way. There are methods which are also used by a later process in the resolver called <code class="language-plaintext highlighter-rouge">finalize_imports</code>, where
some postprocessing is done for each import (error reporting, exporting bindings, …). These methods take an optional parameter <code class="language-plaintext highlighter-rouge">finalize</code> and it does some extra work
depending on whether that parameter is present or not. So when we are in <code class="language-plaintext highlighter-rouge">finalize_imports</code>, this parameter is given.</p>

<p>To fix this, we introduced a <code class="language-plaintext highlighter-rouge">Conditional Mutable Resolver</code> or <code class="language-plaintext highlighter-rouge">CmResolver</code> for short in <a href="https://github.com/rust-lang/rust/pull/144912">#144912</a>, which can give out mutable reference to the resolver based on a particular condition:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">struct</span> <span class="n">RefOrMut</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">p</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="n">T</span><span class="p">,</span>
  <span class="n">mutable</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">}</span>
<span class="k">type</span> <span class="n">CmResolver</span><span class="o">&lt;</span><span class="nv">'r</span><span class="p">,</span> <span class="nv">'ra</span><span class="p">,</span> <span class="nv">'tcx</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">RefOrMut</span><span class="o">&lt;</span><span class="nv">'r</span><span class="p">,</span> <span class="n">Resolver</span><span class="o">&lt;</span><span class="nv">'ra</span><span class="p">,</span> <span class="nv">'tcx</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="c1">// construct:</span>
<span class="k">fn</span> <span class="n">cm</span><span class="o">&lt;</span><span class="nv">'r</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'r</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">CmResolver</span><span class="o">&lt;</span><span class="nv">'r</span><span class="p">,</span> <span class="nv">'ra</span><span class="p">,</span> <span class="nv">'tcx</span><span class="o">&gt;</span><span class="p">{</span>
  <span class="nn">CmResolver</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="o">!</span><span class="k">self</span><span class="py">.assert_speculative</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">assert_speculative</code> is a flag that is set and unset in the code for import resolution. Now we could change the relevant methods to take in a <code class="language-plaintext highlighter-rouge">self: CmResolver</code> instead of a <code class="language-plaintext highlighter-rouge">&amp;mut Resolver</code>.
This type acts as a safeguard, it would panic if we would try to get a mutable reference when it’s not allowed.</p>

<p>A related change were the same kind of wrappers around <code class="language-plaintext highlighter-rouge">Cell</code> and <code class="language-plaintext highlighter-rouge">RefCell</code> using the same flag, it would panic as well if we would mutate the underlying Cell. This was introduced in <a href="https://github.com/rust-lang/rust/pull/146283">#146283</a> which would allow us
to make some important types <code class="language-plaintext highlighter-rouge">Send</code> and <code class="language-plaintext highlighter-rouge">Sync</code> safe.</p>

<h2 id="batched-import-resolution">Batched Import Resolution</h2>

<p>This is were the fun began and is still ongoing (it began on Aug 8), you can track the work <a href="https://github.com/rust-lang/rust/pull/145108">here</a>.
As I said in the beginning, we must resolve all undetermined imports, collect their side effects, and write them to the resolver the same way the current algorithm does.
Import resolution works with 2 kinds of imports: single imports (<code class="language-plaintext highlighter-rouge">use foo::bar</code>) and glob imports (<code class="language-plaintext highlighter-rouge">use foo::*</code>), the side-effects from these are also different. Converting this algorithm proved to be difficult,
any change I did that messed up the order resulted in failure to compile <code class="language-plaintext highlighter-rouge">std</code>, which made it hard to debug.</p>

<p>The first thing I encountered which took me off guard was a bug caused by the implicit prelude the compiler injects into your crate. It’s the first import that gets resolved, and every import after that depends on it:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#![feature(prelude_import)]</span>
<span class="nd">#[prelude_import]</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">prelude</span><span class="p">::</span><span class="nn">v1</span><span class="p">::</span><span class="o">*</span><span class="p">;</span> <span class="c1">// a glob import</span>
<span class="nd">#[macro_use]</span>
<span class="k">extern</span> <span class="k">crate</span> <span class="n">std</span><span class="p">;</span>
</code></pre></div></div>

<p>Because we collect side-effects of imports, we also collect the side-effects of this special prelude import. Delaying these side-effects caused a bunch of confusing errors. <a href="https://github.com/rust-lang/rust/pull/145322">This PR</a>
resolves the prelude import the moment we encounter it in the AST<sup id="fnref:2"><a href="#fn:2" class="footnote" rel="footnote" role="doc-noteref">2</a></sup>, thus never adding it to the set of undetermined imports. The resolver thus always sees the side effects of the prelude import when resolving
the undetermined set.</p>

<hr />

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1">
      <p>The overall algorithm is called Macro Expansion, but it really is the expansion of the entire AST. But because macros influence everything related to the AST, even imports, we just keep this name as is. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>It also helped a little with <a href="https://github.com/rust-lang/rust/pull/139493">this important PR</a>, yeah! <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Lorrens Pantelis</name></author><summary type="html"><![CDATA[The project]]></summary></entry><entry><title type="html">Test Post</title><link href="http://localhost:4000/2025/07/15/test-post.html" rel="alternate" type="text/html" title="Test Post" /><published>2025-07-15T00:00:00+02:00</published><updated>2025-07-15T00:00:00+02:00</updated><id>http://localhost:4000/2025/07/15/test-post</id><content type="html" xml:base="http://localhost:4000/2025/07/15/test-post.html"><![CDATA[<p>It’s working?
Edit: Yes</p>]]></content><author><name>Lorrens Pantelis</name></author><summary type="html"><![CDATA[It’s working? Edit: Yes]]></summary></entry></feed>